// Generated by CoffeeScript 1.10.0
(function() {
  var SeapigMasterObject, SeapigObject, SeapigSlaveObject, SeapigWildcardSlaveObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  this.SeapigClient = (function() {
    function SeapigClient(uri, options) {
      if (options == null) {
        options = {};
      }
      this.uri = uri;
      this.options = options;
      this.slave_objects = {};
      this.master_objects = {};
      this.connected = false;
      this.socket = void 0;
      this.error = void 0;
      this.connect();
    }

    SeapigClient.prototype.connect = function() {
      var error, error1;
      this.reconnect_on_close = true;
      if (this.socket != null) {
        return this.socket.close();
      }
      try {
        this.socket = new WebSocket(this.uri);
      } catch (error1) {
        error = error1;
        this.error = {
          "while": "connecting",
          error: error
        };
        if (this.onstatuschange_proc != null) {
          this.onstatuschange_proc(this);
        }
        return false;
      }
      this.socket.onopen = (function(_this) {
        return function() {
          var id, object, ref, ref1, results;
          if (_this.options.debug) {
            console.log('Connected to seapig server');
          }
          _this.connected = true;
          _this.error = null;
          if (_this.onstatuschange_proc != null) {
            _this.onstatuschange_proc(_this);
          }
          _this.socket.send(JSON.stringify({
            action: 'client-options-set',
            options: _this.options
          }));
          ref = _this.slave_objects;
          for (id in ref) {
            object = ref[id];
            _this.socket.send(JSON.stringify({
              action: 'object-consumer-register',
              pattern: id,
              "version-known": object.version
            }));
            object.validate();
          }
          ref1 = _this.master_objects;
          results = [];
          for (id in ref1) {
            object = ref1[id];
            results.push(_this.socket.send(JSON.stringify({
              action: 'object-producer-register',
              pattern: id,
              "version-known": object.version
            })));
          }
          return results;
        };
      })(this);
      this.socket.onclose = (function(_this) {
        return function() {
          var id, object, ref;
          if (_this.options.debug) {
            console.log('Seapig connection closed');
          }
          _this.connected = false;
          _this.socket = void 0;
          ref = _this.slave_objects;
          for (id in ref) {
            object = ref[id];
            object.invalidate();
          }
          if (_this.onstatuschange_proc != null) {
            _this.onstatuschange_proc(_this);
          }
          if (_this.reconnect_on_close) {
            return _this.reconnection_timer = setTimeout((function() {
              _this.reconnection_timer = void 0;
              return _this.connect();
            }), 2000);
          }
        };
      })(this);
      this.socket.onerror = (function(_this) {
        return function(error) {
          if (_this.options.debug) {
            console.log('Seapig socket error', error);
          }
          return _this.error = {
            "while": "connected",
            error: error
          };
        };
      })(this);
      return this.socket.onmessage = (function(_this) {
        return function(event) {
          var handler, id, message, object, ref, ref1, ref2;
          message = JSON.parse(event.data);
          switch (message.action) {
            case 'object-update':
              ref = _this.slave_objects;
              for (id in ref) {
                object = ref[id];
                if (object.matches(message['id'])) {
                  object.patch(message);
                }
              }
              break;
            case 'object-destroy':
              ref1 = _this.slave_objects;
              for (id in ref1) {
                object = ref1[id];
                if (object.matches(message['id'])) {
                  object.destroy(message['id']);
                }
              }
              ref2 = _this.master_objects;
              for (id in ref2) {
                object = ref2[id];
                if (object.matches(message['id'])) {
                  object.destroy(message['id']);
                }
              }
              break;
            case 'object-produce':
              handler = _.find(_.values(_this.master_objects), function(object) {
                return object.matches(message['id']);
              });
              if ((!handler) && _this.options.debug) {
                console.error('Seapig server submitted invalid "produce" request', message);
              }
              if (handler) {
                handler.produce(message['id'], message['version-inferred']);
              }
              break;
            default:
              if (_this.options.debug) {
                console.error('Seapig server submitted an unsupported message', message);
              }
          }
          return null;
        };
      })(this);
    };

    SeapigClient.prototype.disconnect = function() {
      this.reconnect_on_close = false;
      if (this.reconnection_timer != null) {
        clearTimeout(this.reconnection_timer);
      }
      if (this.socket != null) {
        return this.socket.close();
      }
    };

    SeapigClient.prototype.onstatuschange = function(proc) {
      this.onstatuschange_proc = proc;
      return this;
    };

    SeapigClient.prototype.slave = function(id, options) {
      if (options == null) {
        options = {};
      }
      if ((options["object"] && !options['version']) || (!options["object"] && options['version'])) {
        throw "Both or none of 'object' and 'version' are needed";
      }
      this.slave_objects[id] = id.indexOf('*') >= 0 ? new SeapigWildcardSlaveObject(this, id, options) : new SeapigSlaveObject(this, id, options);
      if (this.connected) {
        this.socket.send(JSON.stringify({
          action: 'object-consumer-register',
          pattern: id,
          "version-known": this.slave_objects[id].version
        }));
      }
      return this.slave_objects[id];
    };

    SeapigClient.prototype.master = function(id, options) {
      if (options == null) {
        options = {};
      }
      this.master_objects[id] = id.indexOf('*') >= 0 ? new SeapigWildcardMasterObject(this, id, options) : new SeapigMasterObject(this, id, options);
      if (this.connected) {
        this.socket.send(JSON.stringify({
          action: 'object-producer-register',
          pattern: id,
          "version-known": this.master_objects[id].version
        }));
      }
      return this.master_objects[id];
    };

    SeapigClient.prototype.unlink = function(id) {
      if (this.slave_objects[id] != null) {
        delete this.slave_objects[id];
        if (this.connected) {
          this.socket.send(JSON.stringify({
            action: 'object-consumer-unregister',
            pattern: id
          }));
        }
      }
      if (this.master_objects[id] != null) {
        delete this.master_objects[id];
        if (this.connected) {
          return this.socket.send(JSON.stringify({
            action: 'object-producer-unregister',
            pattern: id
          }));
        }
      }
    };

    return SeapigClient;

  })();

  SeapigObject = (function() {
    function SeapigObject(client, id, options) {
      this.client = client;
      this.id = id;
      this.destroyed = false;
      this.object = {};
      this.initialized = !!options.object;
      if (options.object != null) {
        _.extend(this.object, options.object);
      }
    }

    SeapigObject.prototype.destroy = function(id) {
      this.destroyed = true;
      if (this.onstatuschange_proc != null) {
        this.onstatuschange_proc(this);
      }
      if (this.ondestroy_proc != null) {
        return this.ondestroy_proc(this);
      }
    };

    SeapigObject.prototype.matches = function(id) {
      return id.match(new RegExp(this.id.replace(/[^A-Za-z0-9*]/g, "\\$&").replace("*", ".*?")));
    };

    SeapigObject.prototype.sanitized = function() {
      return JSON.parse(JSON.stringify(this.object));
    };

    SeapigObject.prototype.ondestroy = function(proc) {
      this.ondestroy_proc = proc;
      return this;
    };

    SeapigObject.prototype.onstatuschange = function(proc) {
      this.onstatuschange_proc = proc;
      return this;
    };

    SeapigObject.prototype.unlink = function() {
      return this.client.unlink(this.id);
    };

    return SeapigObject;

  })();

  SeapigSlaveObject = (function(superClass) {
    extend(SeapigSlaveObject, superClass);

    function SeapigSlaveObject(client, id, options) {
      SeapigSlaveObject.__super__.constructor.call(this, client, id, options);
      this.version = options.version || 0;
      this.valid = false;
      this.received_at = null;
    }

    SeapigSlaveObject.prototype.onchange = function(proc) {
      this.onchange_proc = proc;
      return this;
    };

    SeapigSlaveObject.prototype.patch = function(message) {
      var key, old_object, ref, ref1, value;
      this.received_at = new Date();
      old_object = JSON.stringify(this.object);
      if ((!message['version-old']) || (message['version-old'] === 0) || (message.value != null)) {
        ref = this.object;
        for (key in ref) {
          value = ref[key];
          delete this.object[key];
        }
      } else if (!_.isEqual(this.version, message['version-old'])) {
        console.error("Seapig lost some updates, this shouldn't ever happen. object:", this.id, " version:", this.version, " message:", message);
      }
      if (message.value != null) {
        ref1 = message.value;
        for (key in ref1) {
          value = ref1[key];
          this.object[key] = value;
        }
      } else {
        jsonpatch.apply(this.object, message.patch);
      }
      this.version = message['version-new'];
      this.valid = true;
      this.initialized = true;
      if (this.onstatuschange_proc != null) {
        this.onstatuschange_proc(this);
      }
      if ((this.onchange_proc != null) && old_object !== JSON.stringify(this.object)) {
        return this.onchange_proc(this);
      }
    };

    SeapigSlaveObject.prototype.validate = function() {
      this.valid = this.initialized;
      if (this.onstatuschange_proc != null) {
        return this.onstatuschange_proc(this);
      }
    };

    SeapigSlaveObject.prototype.invalidate = function() {
      this.valid = false;
      if (this.onstatuschange_proc != null) {
        return this.onstatuschange_proc(this);
      }
    };

    return SeapigSlaveObject;

  })(SeapigObject);

  SeapigMasterObject = (function(superClass) {
    extend(SeapigMasterObject, superClass);

    function SeapigMasterObject(client, id, options) {
      SeapigMasterObject.__super__.constructor.call(this, client, id, options);
      this.version = options.version || [(new Date()).getTime(), 0];
      this.shadow = this.sanitized();
      this.stall = false;
    }

    SeapigMasterObject.prototype.onproduce = function(proc) {
      this.onproduce_proc = proc;
      return this;
    };

    SeapigMasterObject.prototype.set = function(options) {
      var key, ref, value;
      if (options == null) {
        options = {};
      }
      if (options.version != null) {
        this.version = options.version;
      }
      if (options.object != null) {
        this.stall = false;
        ref = this.object;
        for (key in ref) {
          value = ref[key];
          delete this.object[key];
        }
        _.extend(this.object, options.object);
      } else if (options.object === false || options.stall) {
        this.stall = true;
      }
      this.shadow = this.sanitized();
      this.initialized = true;
      return this.upload(0, {}, this.version, this.stall ? false : this.shadow);
    };

    SeapigMasterObject.prototype.bump = function(options) {
      var data_old, version_old;
      if (options == null) {
        options = {};
      }
      version_old = this.version;
      data_old = this.shadow;
      this.version = options.version || [version_old[0], version_old[1] + 1];
      this.shadow = this.sanitized();
      this.initialized = true;
      return this.upload(version_old, data_old, this.version, this.stall ? false : this.shadow);
    };

    SeapigMasterObject.prototype.produce = function(id, version_inferred) {
      if (this.onproduce_proc != null) {
        return this.onproduce_proc(this, version_inferred);
      } else {
        if (!this.initialized) {
          throw "Master object " + id + " has to either be initialized at all times or have an onproduce callback";
        }
        return this.upload(0, {}, this.version, this.shadow);
      }
    };

    SeapigMasterObject.prototype.upload = function(version_old, data_old, version_new, data_new) {
      var diff;
      if (this.client.connected) {
        if (version_old === 0 || data_new === false) {
          this.client.socket.send(JSON.stringify({
            id: this.id,
            action: 'object-patch',
            "version-new": version_new,
            value: data_new
          }));
        } else {
          diff = jsonpatch.compare(data_old, data_new);
          if (JSON.stringify(diff).length < JSON.stringify(data_new).length) {
            this.client.socket.send(JSON.stringify({
              id: this.id,
              action: 'object-patch',
              'version-old': version_old,
              'version-new': version_new,
              patch: diff
            }));
          } else {
            this.client.socket.send(JSON.stringify({
              id: this.id,
              action: 'object-patch',
              'version-new': version_new,
              value: data_new
            }));
          }
        }
      }
      return this;
    };

    return SeapigMasterObject;

  })(SeapigObject);

  SeapigWildcardSlaveObject = (function(superClass) {
    extend(SeapigWildcardSlaveObject, superClass);

    function SeapigWildcardSlaveObject(client, id, options) {
      SeapigWildcardSlaveObject.__super__.constructor.call(this, client, id, options);
      this.children = {};
    }

    SeapigWildcardSlaveObject.prototype.patch = function(message) {
      if (this.children[message['id']] == null) {
        this.children[message['id']] = new SeapigSlaveObject(this.client, message['id'], {}).onchange(this.onchange_proc).onstatuschange(this.onstatuschange_proc);
        this.object[message['id']] = this.children[message['id']].object;
      }
      return this.children[message['id']].patch(message);
    };

    SeapigWildcardSlaveObject.prototype.destroy = function(id) {
      var destroyed;
      if ((destroyed = this.children[id]) == null) {
        return;
      }
      delete this.object[id];
      delete this.children[id];
      return destroyed.destroy(id);
    };

    return SeapigWildcardSlaveObject;

  })(SeapigSlaveObject);

}).call(this);

//# sourceMappingURL=seapig-client.js.map
